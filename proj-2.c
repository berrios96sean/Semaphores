/**
 * @file proj-2.c
 * @author Sean Berrios
 * @brief
 * @version 0.1
 * @date 2022-07-29
 *
 */

#include <stdio.h>
#include <unistd.h> 
#include "threads.h"


int buffer_size = 0;
int iteration_limit = 0; 
int producers = 0;
int consumers = 0;
int *buffer = 0;
int in = 0;
int out = 0;

typedef struct Semaphore
{
    int value;
    struct TCB_t *sQueue;
} Semaphore;

void initSem(Semaphore *semaphore, int value)
{
    semaphore->sQueue = NULL;
    semaphore->value = value;
}

void P(Semaphore *semaphore)
{
    if (semaphore->value <= 0)
    {
        if (RunQ == NULL)
        {
            exit(0);
        }

        TCB_t *tcb = DelQueue(&RunQ);

        if (tcb->thread_id < 0)
        {
            printf("\n Consumer %d is waiting\n", tcb->thread_id);//
        }
        else if (tcb->thread_id > 0)
        {
            printf("\n Producer %d is waiting\n", tcb->thread_id);
        }
        AddQueue(&(semaphore->sQueue), tcb);
        swapcontext(&(tcb->context), &(RunQ->context));
    }
    else
    {
        semaphore->value--;
    }
}
void V(Semaphore *semaphore)
{
    if (semaphore->sQueue != NULL)
    {
        TCB_t *tcb = DelQueue(&(semaphore->sQueue));
        AddQueue(&RunQ, tcb);
    }
    semaphore->value++;
}

Semaphore *full;
Semaphore *empty;

void producer(int id)
{
    for (int i = 1; i <= iteration_limit; i++)
    {
        while (buffer[in] != 0)
        {
            P(empty);
        }
        printf("\n Producer %d is producing item number %d \n", RunQ->thread_id, i);
        buffer[in] = RunQ->thread_id;  
        in = (in + 1) % buffer_size;
        V(full);
        if (i == iteration_limit && id == RunQ->thread_id)
        {
            TCB_t *current = DelQueue(&RunQ);//s
            swapcontext(&(current->context), &(RunQ->context));
        }
        else
        {
            yield();
        }
    }
}
void consumer(int id)
{
    for (int i = 1; i <= iteration_limit; i++)
    {
        while (buffer[out] == 0)
        {
            P(full);
        }

        printf("\n Consumer %d is consuming item generated by Producer %d \n", -(RunQ->thread_id), buffer[out]);
        buffer[out] = 0;
        out = (out + 1) % buffer_size;
        V(empty);
        if (i == iteration_limit && id == RunQ->thread_id)
        {
            TCB_t *current = DelQueue(&RunQ);
            swapcontext(&(current->context), &(RunQ->context));
        }
        else
        {
            yield();
        }
    }
}
int main()
{
    scanf("%d,%d,%d,%d", &buffer_size, &producers, &consumers, &iteration_limit);
    buffer = (int *)malloc(buffer_size * sizeof(int));
    full = malloc(sizeof(Semaphore));
    empty = malloc(sizeof(Semaphore));
    initSem(empty, 0);
    initSem(full, buffer_size);
    InitQueue(&RunQ);
    for (int i = 0; i < buffer_size; i++)
    {
        buffer[i] = 0;
    }
    for (int i = 0; i < producers + consumers; i++)
    {
        int id;
        scanf("%d", &id);
        if (id > 0)
        {
            start_thread(producer, id);
        }
        else
        {
            start_thread(consumer, id);
        }
    }
    run();
    return 0;
}
