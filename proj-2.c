/**
 * @file proj-2.c
 * @author Sean Berrios
 * @brief
 * @version 0.1
 * @date 2022-07-29
 *
 */

#include <stdio.h>
#include <unistd.h> 
#include "sem.h"


int buffer_size = 0;
int iteration_limit = 0; 
int producers = 0;
int consumers = 0;
int *buffer = 0;
int in = 0;
int out = 0;

Semaphore *full;
Semaphore *empty;

void producer(int id)
{
    for (int i = 1; i <= iteration_limit; i++)
    {
        while (buffer[in] != 0)
        {
            P(empty);
        }
        printf("\n Producer %d is producing item number %d \n", RunQ->thread_id, i);
        buffer[in] = RunQ->thread_id;
        in = (in + 1) % buffer_size;
        V(full);
        if (i == iteration_limit && id == RunQ->thread_id)
        {
            TCB_t *current = DelQueue(&RunQ);//s
            swapcontext(&(current->context), &(RunQ->context));
        }
        else
        {
            yield();
        }
    }
}
void consumer(int id)
{
    for (int i = 1; i <= iteration_limit; i++)
    {
        while (buffer[out] == 0)
        {
            P(full);
        }

        printf("\n Consumer %d is consuming item generated by Producer %d \n", -(RunQ->thread_id), buffer[out]);
        buffer[out] = 0;
        out = (out + 1) % buffer_size;
        V(empty);
        if (i == iteration_limit && id == RunQ->thread_id)
        {
            TCB_t *current = DelQueue(&RunQ);
            swapcontext(&(current->context), &(RunQ->context));
        }
        else
        {
            yield();
        }
    }
}
int main()
{
    scanf("%d,%d,%d,%d", &buffer_size, &producers, &consumers, &iteration_limit);
    buffer = (int *)malloc(buffer_size * sizeof(int));
    full = malloc(sizeof(Semaphore));
    empty = malloc(sizeof(Semaphore));
    initSem(full, 0);
    initSem(empty, buffer_size);
    InitQueue(&RunQ);
    for (int i = 0; i < buffer_size; i++)
    {
        buffer[i] = 0;
    }
    for (int i = 0; i < producers + consumers; i++)
    {
        int id;
        scanf("%d", &id);
        if (id > 0)
        {
            start_thread(producer, id);
        }
        else
        {
            start_thread(consumer, id);
        }
    }
    run();
    return 0;
}
